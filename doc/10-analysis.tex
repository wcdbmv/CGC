\chapter{Аналитический раздел}

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

Одной из основных задач при построении реалистичного изображения является задача удаления объектов или их частей, которые перекрываются другими объектами, то есть являются невидимыми с точки зрения наблюдателя.

Для решения этой задачи выделяют две группы алгоритмов:
\begin{itemize}
	\item Алгоритмы, работающие в объектном пространстве.
	Данные алгоритмы имеют привязку к мировой или физической системе координат.
	Получаемые результаты ограничиваются только точностью вычислений, однако требуют большого объема вычислений, зависящего от требуемой точности и сложности поступающей на вход сцены.
	В эту группу входят алгоритм Робертса, алгоритм со списком приоритетов и~т.~д.

	\item Алгоритмы, работающие в пространстве изображения.
	Данные алгоритмы предполагают привязку к системе координат экрана или картинной плоскости, на которую производится проецирование изображаемых объектов.
	Объем требуемых вычислений значительно меньше, чем у алгоритмов первой группы, и зависит от разрешающей способности экрана и количества объектов на сцене.
	Основными представителями данной группы являются алгоритм Варнока, алгоритм, использующий Z-буфер, и алгоритм трассировки лучей. \cite{Rogers}
\end{itemize}

Для выбора наиболее подходящего для достижения поставленных задач алгоритма из перечисленных, необходимо осуществить их краткий обзор, отобрать критерии для сравнения и выявить алгоритм, который удовлетворяет этим критериям.

\subsection{Алгоритм Робертса}

Алгоритм Робертса представляет собой первое известное решение задачи об удалении невидимых линий.
Данный алгоритм работает в объектном пространстве.
В соответствии с алгоритмом, предварительно из каждого тела удаляются грани, экранируемые самим телом.
Алгоритм Робертса сравнивает каждое из видимых ребер с каждым оставшимся объектом сцены для определения, какая часть или части, если таковые имеются, экранируются этими объектами.

К преимуществам данного алгоритма можно отнести тот факт, что математические методы, используемые в нем, просты, мощны и точны.
Более поздние реализации алгоритма, например использующие предварительную сортировку вдоль оси $z$, демонстрируют почти линейную зависимость от числа объектов.

Недостатком алгоритма Робертса является то, что его вычислительная трудоемкость растет как квадрат числа объектов на сцене.
Реализация оптимизированных алгоритмов весьма сложна.

\subsection{Алгоритм Варнока}

Алгоритм Варнока работает в пространстве изображения.
В основе этого алгоритма лежит использование свойства когерентности изображения, то есть однородности его смежных областей. \cite{Rogers}\cite{Newman}

Простой для визуализации будем считать некоторую область изображения, полигон в которой отсутствует или является единственным и не пересекает границы данной области (см. рис. \ref{img:warnock}).
В пространстве изображения рассматривается область и проверяется, является ли оно достаточно простым для визуализации.
Если это не так, то область изображения разделяется на подобласти до тех пор, пока каждая подобласть не станет достаточно простой для визуализации или ее размер не достигнет предела разрешения дисплея.

\img{40mm}{warnock}{Каждая подобласть является простой для визуализации (слева), некоторые подобласти не являются простыми для визуализации (справа)}

В противном же случае разбиение повторяется, и для каждой из вновь полученных подобластей рекурсивно применяется процедура принятия решения.
Предполагается, что с уменьшением размеров области ее перекрывает все меньшее и меньшее количество многоугольников.
Считается, что в пределе будут получены области, содержащие не более одного многоугольника, и решение будет принято достаточно просто.
Если же в процессе разбиения будут оставаться области, содержащие не один многоугольник, то следует продолжать процесс разбиения до тех пор, пока размер области не станет совпадать с одним пикселом.
В этом случае для полученного пикселя необходимо вычислить глубину (значение координаты Z) каждого многоугольника и визуализировать тот из них, у которого максимальное значение этой координаты.

Достоинством данного алгоритма является простота реализации и высокая эффективность в случае, если размеры перекрываемых областей невелики.

Недостатком алгоритма Варнока является использование рекурсивных вызовов, что значительно снижает скорость выполнения в случае больших размеров перекрываемых областей.

\subsection{Алгоритм, использующий Z-буфер}

Данный алгоритм удаления невидимых поверхностей является одним из самых простых и широко используемых.
Его идея заключается в использовании двух буферов: буфера кадра и буфера глубины, также называемого Z-буфером.
Буфер кадра используется для хранения интенсивности каждого пикселя в пространстве изображения.
В буфере глубины запоминается значение координаты Z (глубины) каждого видимого пикселя в пространстве изображения.
В ходе работы алгоритма значение глубины каждого нового пикселя, заносимого в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в Z-буфер.
Если это сравнение показывает, что новый пиксель расположен ближе к наблюдателю, чем пиксель, уже находящийся в буфере кадра, то новый пиксель заносится в буфер кадра и производится корректировка Z-буфера: в него заносится глубина нового пикселя. Если же значение глубины нового пикселя меньше, чем хранящееся в буфере, то осуществляется переход к следующей точке. \cite{Rogers}\cite{Newman}

\img{40mm}{zbuffer}{Пример работы алгоритма z-буфера}

Основными достоинствами данного алгоритма являются простота его реализации, корректная обработка случаев взаимных пересечений объектов, линейная зависимость трудоемкости от числа объектов на сцене, а также отсутствие необходимости предварительной сортировки объектов по глубине, то есть они могут обрабатываться в произвольном порядке.

К недостаткам данного алгоритма относят необходимость выделения памяти под два буфера, каждый из которых имеет размер равный количеству пикселей на экране.

\subsection{Алгоритм трассировки лучей}

В данном алгоритме из каждого пикселя картинной плоскости выходит луч, который пересекает ближайшую к наблюдателю грань, тем самым определяя ближайший объект, препятствующий его дальнейшему распространению (см рис. \ref{img:raytrace}).
Трассировка может прекращаться при пересечении лучом поверхности видимого непрозрачного объекта или применять более полные модели освещения с учетом эффектов отражения одного объекта от поверхности другого, преломления, прозрачности и затенения.

\img{60mm}{raytrace}{Пример работы алгоритма трассировки лучей}

К достоинствам данного алгоритма можно отнести возможность получения изображения гладких объектов без аппроксимации их примитивами (например, треугольниками).
Вычислительная сложность метода линейно зависит от сложности сцены.
Нетрудно реализовать наложение света и тени на объекты.
Качество полученного изображения получается очень реалистичным, этот метод отлично подходит для создания фотореалистичных картин.

Серьёзным недостатком алгоритма трассировки лучей является производительность.
Для получения изображения необходимо создавать огромное число лучей, проходящих через сцену и отражаемых от объекта.
Это приводит к существенному снижению скорости работы программы.

\subsection{Выбор оптимального алгоритма}

При реализации программы визуализации поверхностей необходимо обеспечить плавную смену кадров при перемещении камеры, поэтому основными критериями сравнения алгоритмов являются зависимость трудоёмкости алгоритма от числа объектов на сцене и использование рекурсивных вызовов, требующее значительных временных затрат.

Факт задействования дополнительной памяти под буферы не является весомым критерием и может быть опущен, так как среднестатистический компьютер имеет 8 Гб оперативной памяти \cite{steam}.

Наибольшее распространение в современном программном обеспечении получили алгоритмы трассировки лучей и Z-буфера: алгоритм Z-буфера используется в большинстве графических движков, а алгоритм трассировки лучей используется в ПО для создания фотореалистичных сцен.

Алгоритм, использующий Z-буфер, соответствует всем отобранным критериям:
\begin{itemize}
	\item низкая сложность реализации;
	\item линейная трудоёмкости от числа объектов $N$;
	\item широкая распространённость в современном ПО;
	\item не использует рекурсивных вызовов.
\end{itemize}

\section{Анализ алгоритмов закраски}

Существуют три основных алгоритма, позволяющих закрасить полигональную модель: простая закраска, закраска по Гуро и закраска по Фонгу.

\subsection{Простая модель освещения}

Суть данного алгоритма заключается в том, что для каждой грани объекта находится вектор нормали, и с его помощью в соответствии с выбранной моделью освещения вычисляется значение интенсивности, с которой закрашивается вся грань. \cite{Dunn}

К достоинствам метода можно отнести производительность.
Заметим, что все точки грани будут иметь одинаковую интенсивность, что является недостатком алгоритма.

\subsection{Закраска по Гуро}

Данный метод отличается от простой закраски тем, что разные точки грани закрашиваются с разными значениями интенсивности.
Для это в каждой вершине грани находится вектор нормали и вычисляется значение интенсивности. Затем найденные значения интенсивности интерполируются по всем точкам грани. \cite{Dunn}

Закраска по Гуро позволяет получить реалистичное диффузное отражение.
К недостаткам данного алгоритма можно отнести возможность появления эффекта полос Маха.

\subsection{Закраска по Фонгу}

Закраска Фонга по своей идее похожа на закраску Гуро, но ее отличие состоит в том, что в методе Гуро по всем точкам полигона интерполируются значения интенсивностей, а в методе Фонга – вектора нормалей, и с их помощью для каждой точки находится значения интенсивностей, а в методе Фонга – вектора нормалей, и с их помощью для каждой точки находится значение интенсивности. \cite{Dunn}

Данный алгоритм позволяет получить реалистичное зеркальное отражение.
Хотя метод Фонга устраняет большинство недостатков предыдущего метода, он также основан на линейной интерполяции, поэтому в местах разрыва первой производной интенсивности заметен эффект полос Маха, однако менее выраженный, чем при закраске Гуро.

\subsection{Выбор алгоритма закраски}

На рисунке \ref{img:fill} наглядно показаны различия рассмотренных методов закраски.

\img{60mm}{fill}{Методы закраски (слева направо: плоская, Гуро, Фонга)}

Так как для удаления невидимых поверхностей мы выбрали Z-буфер, в котором используется интерполяция для вычисления глубины каждый точки, нам хорошо подойдёт закраска по Гуро, так же требующая интерполяцию.
Совмещение алгоритма Z-буфера и алгоритма Гуро позволит сократить объем вычислений за счёт исключения этапа формирования промежуточного массива точек изображения, который является исходным для определения цвета каждой точки изображения.

\section*{Вывод}

В результате проведенного анализа в качестве алгоритма удаления невидимых линий был выбран алгоритм, использующий Z-буфер, в качестве алгоритма закраски — алгоритм закраски по Гуро.

Предложен метод сокращения объемов вычислений за счёт исключения этапа формирования промежуточного массива точек изображения.
